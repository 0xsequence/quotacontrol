/* eslint-disable */
// quota-control v0-25.11.13+0d4cac4 7ea282d005dd4e53610e1945ac64e528f9219e94
// --
// Code generated by Webrpc-gen@v0.31.1 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=quotacontrol.ridl -target=typescript -client -out=./quotacontrol.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v0-25.11.13+0d4cac4"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "7ea282d005dd4e53610e1945ac64e528f9219e94"

//
// Client interface
//

export interface QuotaControlClient {
  /**
   * Status
   */
  getProjectStatus(req: GetProjectStatusRequest, headers?: object, signal?: AbortSignal): Promise<GetProjectStatusResponse>

  /**
   * Access Key
   */
  getAccessKey(req: GetAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessKeyResponse>

  createAccessKey(req: CreateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<CreateAccessKeyResponse>

  updateAccessKey(req: UpdateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<UpdateAccessKeyResponse>

  listAccessKeys(req: ListAccessKeysRequest, headers?: object, signal?: AbortSignal): Promise<ListAccessKeysResponse>

  rotateAccessKey(req: RotateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<RotateAccessKeyResponse>

  disableAccessKey(req: DisableAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<DisableAccessKeyResponse>

  /**
   * Default Access Keys
   */
  getDefaultAccessKey(req: GetDefaultAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetDefaultAccessKeyResponse>

  setDefaultAccessKey(req: SetDefaultAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<SetDefaultAccessKeyResponse>

  /**
   * Quota
   */
  getProjectQuota(req: GetProjectQuotaRequest, headers?: object, signal?: AbortSignal): Promise<GetProjectQuotaResponse>

  getAccessQuota(req: GetAccessQuotaRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessQuotaResponse>

  clearAccessQuotaCache(req: ClearAccessQuotaCacheRequest, headers?: object, signal?: AbortSignal): Promise<ClearAccessQuotaCacheResponse>

  /**
   * Usage
   */
  getUsage(req: GetUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetUsageResponse>

  clearUsage(req: ClearUsageRequest, headers?: object, signal?: AbortSignal): Promise<ClearUsageResponse>

  syncProjectUsage(req: SyncProjectUsageRequest, headers?: object, signal?: AbortSignal): Promise<SyncProjectUsageResponse>

  syncAccessKeyUsage(req: SyncAccessKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<SyncAccessKeyUsageResponse>

  notifyEvent(req: NotifyEventRequest, headers?: object, signal?: AbortSignal): Promise<NotifyEventResponse>

  /**
   * User permissions for a projectId
   */
  getUserPermission(req: GetUserPermissionRequest, headers?: object, signal?: AbortSignal): Promise<GetUserPermissionResponse>

  /**
   * Deprecated: use GetUsage
   */
  getAccountUsage(req: GetAccountUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAccountUsageResponse>

  /**
   * Deprecated: use GetUsage
   */
  getAccessKeyUsage(req: GetAccessKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessKeyUsageResponse>

  /**
   * Deprecated: use GetUsage
   */
  getAsyncUsage(req: GetAsyncUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAsyncUsageResponse>

  /**
   * Deprecated: use SyncProjectUsage
   */
  updateProjectUsage(req: UpdateProjectUsageRequest, headers?: object, signal?: AbortSignal): Promise<UpdateProjectUsageResponse>

  /**
   * Deprecated: use SyncAccessKeyUsage
   */
  updateKeyUsage(req: UpdateKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<UpdateKeyUsageResponse>

  /**
   * Deprecated: client handles caching directly now, this will be removed in the future
   */
  prepareUsage(req: PrepareUsageRequest, headers?: object, signal?: AbortSignal): Promise<PrepareUsageResponse>
}


//
// Schema types
//

export enum Service {
  NodeGateway = 'NodeGateway',
  API = 'API',
  Indexer = 'Indexer',
  Relayer = 'Relayer',
  Metadata = 'Metadata',
  Marketplace = 'Marketplace',
  Builder = 'Builder',
  WaaS = 'WaaS',
  Trails = 'Trails'
}

export enum EventType {
  FreeWarn = 'FreeWarn',
  FreeMax = 'FreeMax',
  OverWarn = 'OverWarn',
  OverMax = 'OverMax'
}

export enum UserPermission {
  UNAUTHORIZED = 'UNAUTHORIZED',
  READ = 'READ',
  READ_WRITE = 'READ_WRITE',
  ADMIN = 'ADMIN'
}

export interface Limit {
  serviceLimit: {[key: string]: ServiceLimit}
  rateLimit: number
  freeWarn: number
  freeMax: number
  overWarn: number
  overMax: number
}

export interface ServiceLimit {
  rateLimit: number
  freeWarn: number
  freeMax: number
  overWarn: number
  overMax: number
}

export interface AccessKey {
  projectId: number
  chainIds: Array<number>
  displayName: string
  accessKey: string
  active: boolean
  default: boolean
  requireOrigin: boolean
  allowedOrigins: Array<string>
  allowedServices: Array<Service>
  createdAt?: string
}

export interface AccessUsage {
  validCompute: number
  overCompute: number
  limitedCompute: number
}

export interface Cycle {
  start: string
  end: string
}

export interface AccessQuota {
  cycle: Cycle
  limit: Limit
  accessKey: AccessKey
}

export interface ProjectStatus {
  projectId: number
  limit: Limit
  usageCounter: {[key: string]: number}
  rateLimitCounter: {[key: string]: number}
}

export interface Subscription {
  tier: string
}

export interface Minter {
  contracts: Array<string>
}

export interface ResourceAccess {
  projectId: number
  subscription: Subscription
  minter: Minter
}

export interface GetProjectStatusRequest {
  projectId: number
}

export interface GetProjectStatusResponse {
  projectStatus: ProjectStatus
}

export interface GetAccessKeyRequest {
  accessKey: string
}

export interface GetAccessKeyResponse {
  accessKey: AccessKey
}

export interface CreateAccessKeyRequest {
  projectId: number
  displayName: string
  requireOrigin: boolean
  allowedOrigins: Array<string>
  allowedServices: Array<Service>
}

export interface CreateAccessKeyResponse {
  accessKey: AccessKey
}

export interface UpdateAccessKeyRequest {
  accessKey: string
  displayName?: string
  requireOrigin?: boolean
  allowedOrigins?: Array<string>
  allowedServices?: Array<Service>
}

export interface UpdateAccessKeyResponse {
  accessKey: AccessKey
}

export interface ListAccessKeysRequest {
  projectId: number
  active?: boolean
  service?: Service
}

export interface ListAccessKeysResponse {
  accessKeys: Array<AccessKey>
}

export interface RotateAccessKeyRequest {
  accessKey: string
}

export interface RotateAccessKeyResponse {
  accessKey: AccessKey
}

export interface DisableAccessKeyRequest {
  accessKey: string
}

export interface DisableAccessKeyResponse {
  ok: boolean
}

export interface GetDefaultAccessKeyRequest {
  projectID: number
}

export interface GetDefaultAccessKeyResponse {
  accessKey: AccessKey
}

export interface SetDefaultAccessKeyRequest {
  projectID: number
  accessKey: string
}

export interface SetDefaultAccessKeyResponse {
  ok: boolean
}

export interface GetProjectQuotaRequest {
  projectId: number
  now: string
}

export interface GetProjectQuotaResponse {
  accessQuota: AccessQuota
}

export interface GetAccessQuotaRequest {
  accessKey: string
  now: string
}

export interface GetAccessQuotaResponse {
  accessQuota: AccessQuota
}

export interface ClearAccessQuotaCacheRequest {
  projectID: number
}

export interface ClearAccessQuotaCacheResponse {
  ok: boolean
}

export interface GetUsageRequest {
  projectID: number
  accessKey?: string
  service?: Service
  from?: string
  to?: string
}

export interface GetUsageResponse {
  usage: number
}

export interface ClearUsageRequest {
  projectID: number
  service?: Service
  now: string
}

export interface ClearUsageResponse {
  ok: boolean
}

export interface SyncProjectUsageRequest {
  service: Service
  now: string
  usage: {[key: number]: number}
}

export interface SyncProjectUsageResponse {
  ok: {[key: number]: boolean}
}

export interface SyncAccessKeyUsageRequest {
  service: Service
  now: string
  usage: {[key: string]: number}
}

export interface SyncAccessKeyUsageResponse {
  ok: {[key: string]: boolean}
}

export interface NotifyEventRequest {
  projectID: number
  service: Service
  eventType: EventType
}

export interface NotifyEventResponse {
  ok: boolean
}

export interface GetUserPermissionRequest {
  projectId: number
  userId: string
}

export interface GetUserPermissionResponse {
  permission: UserPermission
  resourceAccess: ResourceAccess
}

export interface GetAccountUsageRequest {
  projectID: number
  service?: Service
  from?: string
  to?: string
}

export interface GetAccountUsageResponse {
  usage: AccessUsage
}

export interface GetAccessKeyUsageRequest {
  accessKey: string
  service?: Service
  from?: string
  to?: string
}

export interface GetAccessKeyUsageResponse {
  usage: AccessUsage
}

export interface GetAsyncUsageRequest {
  projectID: number
  service?: Service
  from?: string
  to?: string
}

export interface GetAsyncUsageResponse {
  usage: AccessUsage
}

export interface UpdateProjectUsageRequest {
  service: Service
  now: string
  usage: {[key: number]: AccessUsage}
}

export interface UpdateProjectUsageResponse {
  ok: {[key: number]: boolean}
}

export interface UpdateKeyUsageRequest {
  service: Service
  now: string
  usage: {[key: string]: AccessUsage}
}

export interface UpdateKeyUsageResponse {
  ok: {[key: string]: boolean}
}

export interface PrepareUsageRequest {
  projectID: number
  service?: Service
  cycle: Cycle
  now: string
}

export interface PrepareUsageResponse {
  ok: boolean
}



//
// Client
//

export class QuotaControl implements QuotaControlClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/QuotaControl/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  queryKey = {
    getProjectStatus: (req: GetProjectStatusRequest) => ['QuotaControl', 'getProjectStatus', req] as const,
    getAccessKey: (req: GetAccessKeyRequest) => ['QuotaControl', 'getAccessKey', req] as const,
    createAccessKey: (req: CreateAccessKeyRequest) => ['QuotaControl', 'createAccessKey', req] as const,
    updateAccessKey: (req: UpdateAccessKeyRequest) => ['QuotaControl', 'updateAccessKey', req] as const,
    listAccessKeys: (req: ListAccessKeysRequest) => ['QuotaControl', 'listAccessKeys', req] as const,
    rotateAccessKey: (req: RotateAccessKeyRequest) => ['QuotaControl', 'rotateAccessKey', req] as const,
    disableAccessKey: (req: DisableAccessKeyRequest) => ['QuotaControl', 'disableAccessKey', req] as const,
    getDefaultAccessKey: (req: GetDefaultAccessKeyRequest) => ['QuotaControl', 'getDefaultAccessKey', req] as const,
    setDefaultAccessKey: (req: SetDefaultAccessKeyRequest) => ['QuotaControl', 'setDefaultAccessKey', req] as const,
    getProjectQuota: (req: GetProjectQuotaRequest) => ['QuotaControl', 'getProjectQuota', req] as const,
    getAccessQuota: (req: GetAccessQuotaRequest) => ['QuotaControl', 'getAccessQuota', req] as const,
    clearAccessQuotaCache: (req: ClearAccessQuotaCacheRequest) => ['QuotaControl', 'clearAccessQuotaCache', req] as const,
    getUsage: (req: GetUsageRequest) => ['QuotaControl', 'getUsage', req] as const,
    clearUsage: (req: ClearUsageRequest) => ['QuotaControl', 'clearUsage', req] as const,
    syncProjectUsage: (req: SyncProjectUsageRequest) => ['QuotaControl', 'syncProjectUsage', req] as const,
    syncAccessKeyUsage: (req: SyncAccessKeyUsageRequest) => ['QuotaControl', 'syncAccessKeyUsage', req] as const,
    notifyEvent: (req: NotifyEventRequest) => ['QuotaControl', 'notifyEvent', req] as const,
    getUserPermission: (req: GetUserPermissionRequest) => ['QuotaControl', 'getUserPermission', req] as const,
    getAccountUsage: (req: GetAccountUsageRequest) => ['QuotaControl', 'getAccountUsage', req] as const,
    getAccessKeyUsage: (req: GetAccessKeyUsageRequest) => ['QuotaControl', 'getAccessKeyUsage', req] as const,
    getAsyncUsage: (req: GetAsyncUsageRequest) => ['QuotaControl', 'getAsyncUsage', req] as const,
    updateProjectUsage: (req: UpdateProjectUsageRequest) => ['QuotaControl', 'updateProjectUsage', req] as const,
    updateKeyUsage: (req: UpdateKeyUsageRequest) => ['QuotaControl', 'updateKeyUsage', req] as const,
    prepareUsage: (req: PrepareUsageRequest) => ['QuotaControl', 'prepareUsage', req] as const,
  }

  getProjectStatus = (req: GetProjectStatusRequest, headers?: object, signal?: AbortSignal): Promise<GetProjectStatusResponse> => {
    return this.fetch(
      this.url('GetProjectStatus'),
      createHttpRequest(JsonEncode(req, 'GetProjectStatusRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetProjectStatusResponse>(_data, 'GetProjectStatusResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getAccessKey = (req: GetAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessKeyResponse> => {
    return this.fetch(
      this.url('GetAccessKey'),
      createHttpRequest(JsonEncode(req, 'GetAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetAccessKeyResponse>(_data, 'GetAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  createAccessKey = (req: CreateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<CreateAccessKeyResponse> => {
    return this.fetch(
      this.url('CreateAccessKey'),
      createHttpRequest(JsonEncode(req, 'CreateAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<CreateAccessKeyResponse>(_data, 'CreateAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  updateAccessKey = (req: UpdateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<UpdateAccessKeyResponse> => {
    return this.fetch(
      this.url('UpdateAccessKey'),
      createHttpRequest(JsonEncode(req, 'UpdateAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<UpdateAccessKeyResponse>(_data, 'UpdateAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  listAccessKeys = (req: ListAccessKeysRequest, headers?: object, signal?: AbortSignal): Promise<ListAccessKeysResponse> => {
    return this.fetch(
      this.url('ListAccessKeys'),
      createHttpRequest(JsonEncode(req, 'ListAccessKeysRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ListAccessKeysResponse>(_data, 'ListAccessKeysResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  rotateAccessKey = (req: RotateAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<RotateAccessKeyResponse> => {
    return this.fetch(
      this.url('RotateAccessKey'),
      createHttpRequest(JsonEncode(req, 'RotateAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<RotateAccessKeyResponse>(_data, 'RotateAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  disableAccessKey = (req: DisableAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<DisableAccessKeyResponse> => {
    return this.fetch(
      this.url('DisableAccessKey'),
      createHttpRequest(JsonEncode(req, 'DisableAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<DisableAccessKeyResponse>(_data, 'DisableAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getDefaultAccessKey = (req: GetDefaultAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<GetDefaultAccessKeyResponse> => {
    return this.fetch(
      this.url('GetDefaultAccessKey'),
      createHttpRequest(JsonEncode(req, 'GetDefaultAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetDefaultAccessKeyResponse>(_data, 'GetDefaultAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  setDefaultAccessKey = (req: SetDefaultAccessKeyRequest, headers?: object, signal?: AbortSignal): Promise<SetDefaultAccessKeyResponse> => {
    return this.fetch(
      this.url('SetDefaultAccessKey'),
      createHttpRequest(JsonEncode(req, 'SetDefaultAccessKeyRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SetDefaultAccessKeyResponse>(_data, 'SetDefaultAccessKeyResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getProjectQuota = (req: GetProjectQuotaRequest, headers?: object, signal?: AbortSignal): Promise<GetProjectQuotaResponse> => {
    return this.fetch(
      this.url('GetProjectQuota'),
      createHttpRequest(JsonEncode(req, 'GetProjectQuotaRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetProjectQuotaResponse>(_data, 'GetProjectQuotaResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getAccessQuota = (req: GetAccessQuotaRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessQuotaResponse> => {
    return this.fetch(
      this.url('GetAccessQuota'),
      createHttpRequest(JsonEncode(req, 'GetAccessQuotaRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetAccessQuotaResponse>(_data, 'GetAccessQuotaResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  clearAccessQuotaCache = (req: ClearAccessQuotaCacheRequest, headers?: object, signal?: AbortSignal): Promise<ClearAccessQuotaCacheResponse> => {
    return this.fetch(
      this.url('ClearAccessQuotaCache'),
      createHttpRequest(JsonEncode(req, 'ClearAccessQuotaCacheRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ClearAccessQuotaCacheResponse>(_data, 'ClearAccessQuotaCacheResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getUsage = (req: GetUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetUsageResponse> => {
    return this.fetch(
      this.url('GetUsage'),
      createHttpRequest(JsonEncode(req, 'GetUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetUsageResponse>(_data, 'GetUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  clearUsage = (req: ClearUsageRequest, headers?: object, signal?: AbortSignal): Promise<ClearUsageResponse> => {
    return this.fetch(
      this.url('ClearUsage'),
      createHttpRequest(JsonEncode(req, 'ClearUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<ClearUsageResponse>(_data, 'ClearUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  syncProjectUsage = (req: SyncProjectUsageRequest, headers?: object, signal?: AbortSignal): Promise<SyncProjectUsageResponse> => {
    return this.fetch(
      this.url('SyncProjectUsage'),
      createHttpRequest(JsonEncode(req, 'SyncProjectUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SyncProjectUsageResponse>(_data, 'SyncProjectUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  syncAccessKeyUsage = (req: SyncAccessKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<SyncAccessKeyUsageResponse> => {
    return this.fetch(
      this.url('SyncAccessKeyUsage'),
      createHttpRequest(JsonEncode(req, 'SyncAccessKeyUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SyncAccessKeyUsageResponse>(_data, 'SyncAccessKeyUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  notifyEvent = (req: NotifyEventRequest, headers?: object, signal?: AbortSignal): Promise<NotifyEventResponse> => {
    return this.fetch(
      this.url('NotifyEvent'),
      createHttpRequest(JsonEncode(req, 'NotifyEventRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<NotifyEventResponse>(_data, 'NotifyEventResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getUserPermission = (req: GetUserPermissionRequest, headers?: object, signal?: AbortSignal): Promise<GetUserPermissionResponse> => {
    return this.fetch(
      this.url('GetUserPermission'),
      createHttpRequest(JsonEncode(req, 'GetUserPermissionRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetUserPermissionResponse>(_data, 'GetUserPermissionResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getAccountUsage = (req: GetAccountUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAccountUsageResponse> => {
    return this.fetch(
      this.url('GetAccountUsage'),
      createHttpRequest(JsonEncode(req, 'GetAccountUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetAccountUsageResponse>(_data, 'GetAccountUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getAccessKeyUsage = (req: GetAccessKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAccessKeyUsageResponse> => {
    return this.fetch(
      this.url('GetAccessKeyUsage'),
      createHttpRequest(JsonEncode(req, 'GetAccessKeyUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetAccessKeyUsageResponse>(_data, 'GetAccessKeyUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getAsyncUsage = (req: GetAsyncUsageRequest, headers?: object, signal?: AbortSignal): Promise<GetAsyncUsageResponse> => {
    return this.fetch(
      this.url('GetAsyncUsage'),
      createHttpRequest(JsonEncode(req, 'GetAsyncUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetAsyncUsageResponse>(_data, 'GetAsyncUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  updateProjectUsage = (req: UpdateProjectUsageRequest, headers?: object, signal?: AbortSignal): Promise<UpdateProjectUsageResponse> => {
    return this.fetch(
      this.url('UpdateProjectUsage'),
      createHttpRequest(JsonEncode(req, 'UpdateProjectUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<UpdateProjectUsageResponse>(_data, 'UpdateProjectUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  updateKeyUsage = (req: UpdateKeyUsageRequest, headers?: object, signal?: AbortSignal): Promise<UpdateKeyUsageResponse> => {
    return this.fetch(
      this.url('UpdateKeyUsage'),
      createHttpRequest(JsonEncode(req, 'UpdateKeyUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<UpdateKeyUsageResponse>(_data, 'UpdateKeyUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  prepareUsage = (req: PrepareUsageRequest, headers?: object, signal?: AbortSignal): Promise<PrepareUsageResponse> => {
    return this.fetch(
      this.url('PrepareUsage'),
      createHttpRequest(JsonEncode(req, 'PrepareUsageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<PrepareUsageResponse>(_data, 'PrepareUsageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json', [WebrpcHeader]: WebrpcHeaderValue }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>






export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try { parsed = JSON.parse(data) } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}


//
// Errors
//

type WebrpcErrorParams = { name?: string, code?: number, message?: string, status?: number, cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}


export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}


//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class MethodNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MethodNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Method not found`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MethodNotFoundError.prototype)
  }
}

export class RequestConflictError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RequestConflict'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Conflict with target resource`
    this.status = typeof error.status === 'number' ? error.status : 409
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RequestConflictError.prototype)
  }
}

export class AbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Aborted'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `Request aborted`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AbortedError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1006
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1007
    this.message = error.message || `Rate limit exceeded. Configure an Access Key to increase your limits: https://dashboard.trails.build or https://sequence.build`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class ProjectNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'ProjectNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1008
    this.message = error.message || `Project not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)
  }
}

export class SecretKeyCorsDisallowedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SecretKeyCorsDisallowed'
    this.code = typeof error.code === 'number' ? error.code : 1009
    this.message = error.message || `CORS disallowed. Admin API Secret Key can't be used from a web app.`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SecretKeyCorsDisallowedError.prototype)
  }
}

export class AccessKeyNotFoundError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyNotFound'
    this.code = typeof error.code === 'number' ? error.code : 1101
    this.message = error.message || `Access key not found`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyNotFoundError.prototype)
  }
}

export class AccessKeyMismatchError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AccessKeyMismatch'
    this.code = typeof error.code === 'number' ? error.code : 1102
    this.message = error.message || `Access key mismatch`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AccessKeyMismatchError.prototype)
  }
}

export class InvalidOriginError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidOrigin'
    this.code = typeof error.code === 'number' ? error.code : 1103
    this.message = error.message || `Invalid origin for Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidOriginError.prototype)
  }
}

export class InvalidServiceError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidService'
    this.code = typeof error.code === 'number' ? error.code : 1104
    this.message = error.message || `Service not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidServiceError.prototype)
  }
}

export class UnauthorizedUserError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'UnauthorizedUser'
    this.code = typeof error.code === 'number' ? error.code : 1105
    this.message = error.message || `Unauthorized user`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedUserError.prototype)
  }
}

export class InvalidChainError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'InvalidChain'
    this.code = typeof error.code === 'number' ? error.code : 1106
    this.message = error.message || `Network not enabled for Access key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, InvalidChainError.prototype)
  }
}

export class QuotaExceededError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaExceeded'
    this.code = typeof error.code === 'number' ? error.code : 1200
    this.message = error.message || `Project quota exceeded. Upgrade your project to increase your limits: https://sequence.build`
    this.status = typeof error.status === 'number' ? error.status : 423
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaExceededError.prototype)
  }
}

export class QuotaRateLimitError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'QuotaRateLimit'
    this.code = typeof error.code === 'number' ? error.code : 1201
    this.message = error.message || `Project rate limit exceeded. Upgrade your project to increase your limits: https://sequence.build`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, QuotaRateLimitError.prototype)
  }
}

export class NoDefaultKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'NoDefaultKey'
    this.code = typeof error.code === 'number' ? error.code : 1300
    this.message = error.message || `No default access key found`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, NoDefaultKeyError.prototype)
  }
}

export class MaxAccessKeysError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'MaxAccessKeys'
    this.code = typeof error.code === 'number' ? error.code : 1301
    this.message = error.message || `Access keys limit reached`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, MaxAccessKeysError.prototype)
  }
}

export class AtLeastOneKeyError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'AtLeastOneKey'
    this.code = typeof error.code === 'number' ? error.code : 1302
    this.message = error.message || `You need at least one Access Key`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, AtLeastOneKeyError.prototype)
  }
}

export class TimeoutError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Timeout'
    this.code = typeof error.code === 'number' ? error.code : 1900
    this.message = error.message || `Request timed out`
    this.status = typeof error.status === 'number' ? error.status : 408
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, TimeoutError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  MethodNotFound = 'MethodNotFound',
  RequestConflict = 'RequestConflict',
  Aborted = 'Aborted',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  ProjectNotFound = 'ProjectNotFound',
  SecretKeyCorsDisallowed = 'SecretKeyCorsDisallowed',
  AccessKeyNotFound = 'AccessKeyNotFound',
  AccessKeyMismatch = 'AccessKeyMismatch',
  InvalidOrigin = 'InvalidOrigin',
  InvalidService = 'InvalidService',
  UnauthorizedUser = 'UnauthorizedUser',
  InvalidChain = 'InvalidChain',
  QuotaExceeded = 'QuotaExceeded',
  QuotaRateLimit = 'QuotaRateLimit',
  NoDefaultKey = 'NoDefaultKey',
  MaxAccessKeys = 'MaxAccessKeys',
  AtLeastOneKey = 'AtLeastOneKey',
  Timeout = 'Timeout',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  MethodNotFound = 1003,
  RequestConflict = 1004,
  Aborted = 1005,
  Geoblocked = 1006,
  RateLimited = 1007,
  ProjectNotFound = 1008,
  SecretKeyCorsDisallowed = 1009,
  AccessKeyNotFound = 1101,
  AccessKeyMismatch = 1102,
  InvalidOrigin = 1103,
  InvalidService = 1104,
  UnauthorizedUser = 1105,
  InvalidChain = 1106,
  QuotaExceeded = 1200,
  QuotaRateLimit = 1201,
  NoDefaultKey = 1300,
  MaxAccessKeys = 1301,
  AtLeastOneKey = 1302,
  Timeout = 1900,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [1006]: GeoblockedError,
  [1007]: RateLimitedError,
  [1008]: ProjectNotFoundError,
  [1009]: SecretKeyCorsDisallowedError,
  [1101]: AccessKeyNotFoundError,
  [1102]: AccessKeyMismatchError,
  [1103]: InvalidOriginError,
  [1104]: InvalidServiceError,
  [1105]: UnauthorizedUserError,
  [1106]: InvalidChainError,
  [1200]: QuotaExceededError,
  [1201]: QuotaRateLimitError,
  [1300]: NoDefaultKeyError,
  [1301]: MaxAccessKeysError,
  [1302]: AtLeastOneKeyError,
  [1900]: TimeoutError,
}



//
// Webrpc
//

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.31.1;gen-typescript@v0.22.5;quota-control@v0-25.11.13+0d4cac4"

type WebrpcGenVersions = {
  WebrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";")
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, WebrpcGenVersion] = versions[0]!.split("@")
  const [codeGenName, codeGenVersion] = versions[1]!.split("@")
  const [schemaName, schemaVersion] = versions[2]!.split("@")

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

